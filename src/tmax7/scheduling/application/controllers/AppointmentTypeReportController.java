package tmax7.scheduling.application.controllers;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.stage.Stage;
import tmax7.scheduling.application.AppointmentType;
import tmax7.scheduling.application.MainApp;

import java.time.LocalDateTime;
import java.time.Month;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class AppointmentTypeReportController {
    private MainApp mainApp;
    private Stage stage;
    private ObservableList<Month> months = FXCollections.observableArrayList(Month.values());
    private ObservableList<Integer> years =FXCollections.observableArrayList();

    private int yearSelected;
    private Month monthSelected;

    private ObservableList<AppointmentType> allAppointmentTypes;

    @FXML
    private ComboBox<Integer> yearsComboBox;
    @FXML
    private ComboBox<Month> monthsComboBox;

    @FXML
    private TableView<AppointmentType> appointmentTypeTableView;

    @FXML
    private TableColumn<AppointmentType, String> appointmentTypeColumn;
    @FXML
    private TableColumn<AppointmentType, Number> numberOfAppointmentsColumn;

    @FXML
    private Label numberOfTypesInMonthLabel;

    @FXML
    private void initialize() {
        appointmentTypeColumn.setCellValueFactory(cellData -> cellData.getValue().typeProperty());
        numberOfAppointmentsColumn.setCellValueFactory(cellData -> cellData.getValue().numberOfAppointmentsWithTypeProperty());

        //disable monthsComboBox so month won't be selected before year
        monthsComboBox.setDisable(true);
    }

    @FXML
    private void onYearSelected() {
        if(yearsComboBox.getSelectionModel().getSelectedItem() != null) {
            yearSelected = yearsComboBox.getSelectionModel().getSelectedItem();
            //enable user to select month
            monthsComboBox.setDisable(false);
        }
        // calls onMonthSelected() when user changes the year after having previously changed the month
        if(monthSelected != null) {
            onMonthSelected();
        }
    }

    @FXML
    private void onMonthSelected() {
        if(monthsComboBox.getSelectionModel().getSelectedItem() != null && yearSelected != 0) {
            monthSelected = monthsComboBox.getSelectionModel().getSelectedItem();

            ObservableList<AppointmentType> appointmentTypesToDisplay = FXCollections.observableArrayList();
            for(AppointmentType appointmentType : allAppointmentTypes) {
                if(appointmentType.getYear() == yearSelected && appointmentType.getMonth().equals(monthSelected)) {
                    appointmentTypesToDisplay.add(appointmentType);
                }
            }

            appointmentTypeTableView.setItems(appointmentTypesToDisplay);
            numberOfTypesInMonthLabel.setText(String.valueOf(appointmentTypesToDisplay.size()));
        }
    }

    @FXML
    private void onOkClicked() {
        stage.close();
    }

    public void setMainApp(MainApp mainApp) {
        this.mainApp = mainApp;
        //set tableView's items with appointment types generated by mainApp
        allAppointmentTypes = mainApp.generateAppointmentTypes();

        //set comboBoxes Items
        monthsComboBox.setItems(months);

        int currentYear = LocalDateTime.now().getYear();
        int yearsLimit = mainApp.getYearsLimit();
        Stream<Integer> streamOfIntegers = Stream.iterate(currentYear, y -> y + 1); //USE OF LAMBDA EXPRESSION: This use of a lambda expression allows the years in the yearsComboBox to change dynamically based on what year the User signs in
        years.addAll(streamOfIntegers.limit(yearsLimit).collect(Collectors.toList()));
        yearsComboBox.setItems(years);
    }

    public void setStage(Stage stage) {
        this.stage = stage;
    }
}
